<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WDD 330 Portfolio Week 9 Notes</title>
    <link rel="stylesheet" href="../style.css">
</head>

<body>
    <header>
        <h1>WDD 330 Portfolio</h1>
        <h4><a href="../index.html">Back to Home</a></h4>
    </header>

    <main>
        <h2>Week 10 Notes</h2>
        <h3>MDN: Validating forms</h3>
        <p>Form validation is important for a professional appearance and it is extremely useful for the UX. Most big
            sites you use will have validation. Some good points were made by this article on reasons validating is
            important:</p>
        <ul>
            <h4>We want to make filling out web forms as easy as possible. So why do we insist on validating our forms?
                There are three main reasons:</h4>
            <li> We want to get the right data, in the right format. Our applications won't work properly if our users'
                data is stored in the wrong format, is incorrect, or is omitted altogether.</li>
            <li>We want to protect our users' data. Forcing our users to enter secure passwords makes it easier to
                protect their account information.</li>
            <li>We want to protect ourselves. There are many ways that malicious users can misuse unprotected forms to
                damage the application (see Website security).</li>
        </ul>
        <h5>required: Specifies whether a form field needs to be filled in before the form can be submitted.</h5>
        <h5>minlength and maxlength: Specifies the minimum and maximum length of textual data (strings)</h5>
        <h5>min and max: Specifies the minimum and maximum values of numerical input types</h5>
        <h5>type: Specifies whether the data needs to be a number, an email address, or some other specific preset type.
        </h5>
        <h5>pattern: Specifies a regular expression that defines a pattern the entered data needs to follow.</h5>
        <ul>
            <h4>Most browsers support the Constraint Validation API, which consists of a set of methods and properties
                available on the following form element DOM interfaces:</h4>
            <li>HTMLButtonElement (represents a &ltbutton&gt element)</li>
            <li>HTMLFieldSetElement (represents a &ltfieldset&gt element)</li>
            <li>HTMLInputElement (represents an &ltinput&gt element)</li>
            <li>HTMLOutputElement (represents an &ltoutput&gt element)</li>
            <li>HTMLSelectElement (represents a &ltselect&gt element)</li>
            <li>HTMLTextAreaElement (represents a &lttextarea&gt element)</li>
        </ul>

        <p>In some cases, such as legacy browser support or custom controls, you won't be able to or won't want to use
            the Constraint Validation API.You're still able to use JavaScript to validate your form, but you'll just
            have to write your own.</p>

        <h3>MDN: Using Fetch</h3>
        <p>The Fetch API provides a JavaScript interface for accessing and manipulating parts of the HTTP pipeline, such
            as requests and responses. It also provides a global fetch() method that provides an easy, logical way to
            fetch resources asynchronously across the network.</p>
        <p>The fetch() method can optionally accept a second parameter, an init object that allows you to control a
            number of different settings. These include:</p>
        <ul>
            <li>method: 'POST', // *GET, POST, PUT, DELETE, etc.</li>
            <li>mode: 'cors', // no-cors, *cors, same-origin</li>
            <li>cache: 'no-cache', // *default, no-cache, reload, force-cache, only-if-cached</li>
            <li>credentials: 'same-origin', // include, *same-origin, omit</li>
            <li>headers: {
                'Content-Type': 'application/json'
                // 'Content-Type': 'application/x-www-form-urlencoded',
                },</li>
            <li>redirect: 'follow', // manual, *follow, error</li>
            <li>referrerPolicy: 'no-referrer', // no-referrer, *no-referrer-when-downgrade, origin,
                origin-when-cross-origin, same-origin, strict-origin, strict-origin-when-cross-origin, unsafe-url</li>
            <li>body: JSON.stringify(data) // body data type must match "Content-Type" header</li>
        </ul>
        <p>A fetch() promise will reject with a TypeError when a network error is encountered or CORS is misconfigured
            on the server-side, although this usually means permission issues or similar â€” a 404 does not constitute a
            network error, for example. An accurate check for a successful fetch() would include checking that the
            promise resolved, then checking that the Response.ok property has a value of true.</p>
        <p>The Headers interface allows you to create your own headers object via the Headers() constructor. A headers
            object is a simple multi-map of names to values:</p>
        <p>const content = 'Hello World';<br>
            const myHeaders = new Headers();<br>
            myHeaders.append('Content-Type', 'text/plain');<br>
            myHeaders.append('Content-Length', content.length.toString());<br>
            myHeaders.append('X-Custom-Header', 'ProcessThisImmediately');
        </p>
        <p>Since headers can be sent in requests and received in responses, and have various limitations about what
            information can and should be mutable, headers' objects have a guard property. This is not exposed to the
            Web, but it affects which mutation operations are allowed on the headers object.</p>
    </main>

    <footer>
        <p>Jordan Gresham | WDD-330 Web Frontend Development II | <a href="https://byui.edu/">BYU-I</a></p>
    </footer>
</body>

</html>